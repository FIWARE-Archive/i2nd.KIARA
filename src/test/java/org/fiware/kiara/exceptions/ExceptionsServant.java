 /* KIARA - Middleware for efficient and QoS/Security-aware invocation of services and exchange of messages
 *
 * Copyright (C) 2014 Proyectos y Sistemas de Mantenimiento S.L. (eProsima)
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library. If not, see <http://www.gnu.org/licenses/>.
 *
 *
 * @file ExceptionsServant.java
 * This file contains the servant processing implementation code. It parses the service executed and calls the corresponding method.
 *
 * This file was generated by using the tool Kiaragen.
 *
 */
package org.fiware.kiara.exceptions;

import java.io.IOException;
import org.fiware.kiara.serialization.Serializer;
import org.fiware.kiara.serialization.impl.CDRSerializer;
import org.fiware.kiara.serialization.impl.SerializerImpl;
import org.fiware.kiara.server.Servant;
import org.fiware.kiara.transport.Transport;
import org.fiware.kiara.transport.impl.TransportImpl;
import org.fiware.kiara.transport.impl.TransportMessage;

import org.fiware.kiara.serialization.impl.BinaryInputStream;
import org.fiware.kiara.serialization.impl.BinaryOutputStream;

/**
 * Abstract class used to process the incoming remote calls.
 *
 * @author Kiaragen tool.
 *
 */
public abstract class ExceptionsServant implements Servant, Exceptions {

	@Override
    public String getServiceName() {
        return "Exceptions";
    }

    private int divide_required_size() {
        int op_size = 0;

        op_size += 4 + CDRSerializer.alignment(op_size, Integer.SIZE); // MessageID
        op_size += 4 + CDRSerializer.alignment(op_size, Integer.SIZE); // Error indicator code
        op_size += 4 + CDRSerializer.alignment(op_size, 4); // Return type

        int currentSize = 0, maxSize = 0;

        currentSize += DividedByZeroException.getMaxCdrSerializedSize(currentSize);
        if (currentSize > maxSize) {
            maxSize = currentSize;
        }
        currentSize = 0;

        return op_size + maxSize;
    }

    private int function_required_size() {
        int op_size = 0;

        op_size += 4 + CDRSerializer.alignment(op_size, Integer.SIZE); // MessageID
        op_size += 4 + CDRSerializer.alignment(op_size, Integer.SIZE); // Error indicator code
        op_size += 4 + CDRSerializer.alignment(op_size, 4); // Return type

        int currentSize = 0, maxSize = 0;

        currentSize += FirstException.getMaxCdrSerializedSize(currentSize);
        if (currentSize > maxSize) {
            maxSize = currentSize;
        }
        currentSize = 0;

        currentSize += SecondException.getMaxCdrSerializedSize(currentSize);
        if (currentSize > maxSize) {
            maxSize = currentSize;
        }
        currentSize = 0;

        return op_size + maxSize;
    }

    @Override
    public TransportMessage process(Serializer ser, Transport transport, Object messageId, BinaryInputStream bis) {

        SerializerImpl serImpl;
        TransportImpl transportImpl;

        if (ser instanceof SerializerImpl && transport instanceof TransportImpl) {
            serImpl = (SerializerImpl) ser;
            transportImpl = (TransportImpl) transport;
        } else {
            return null; // TODO Raise error
        }

        try {
            String operation = serImpl.deserializeOperation(bis);

            if (operation.equals("divide")) {
                float n1 = serImpl.deserializeFloat32(bis, "");
                float n2 = serImpl.deserializeFloat32(bis, "");

                BinaryOutputStream retBuffer = new BinaryOutputStream(divide_required_size());
                TransportMessage retMsg = transportImpl.createTransportMessage(null);
                serImpl.serializeMessageId(retBuffer, messageId);

                try {
                    float ret = divide(n1, n2);
                    // Serialize return code (0 = OK)
                    serImpl.serializeUI32(retBuffer, "", 0);
                    // Serialize return type
                    serImpl.serializeFloat32(retBuffer, "", ret);
                } catch (DividedByZeroException ex_DividedByZeroException) {
                    ex_DividedByZeroException.printStackTrace();
                    // Serialize return code (non-zero error code)
                    serImpl.serializeUI32(retBuffer, "", 0xC0E611C3);
                    // Serialize exception name
                    serImpl.serializeString(retBuffer, "", "DividedByZeroException");
                    // Serialize exception data
                    ex_DividedByZeroException.serialize(serImpl, retBuffer, "");
                }

                retMsg.setPayload(retBuffer.getByteBuffer());
                return retMsg;
            }

            if (operation.equals("function")) {

                BinaryOutputStream retBuffer = new BinaryOutputStream(function_required_size());
                TransportMessage retMsg = transportImpl.createTransportMessage(null);
                serImpl.serializeMessageId(retBuffer, messageId);

                try {
                    int ret = function();
                    // Serialize return code (0 = OK)
                    serImpl.serializeUI32(retBuffer, "", 0);
                    // Serialize return type
                    serImpl.serializeI32(retBuffer, "", ret);
                } catch (FirstException ex_FirstException) {
                    ex_FirstException.printStackTrace();
                    // Serialize return code (non-zero error code)
                    serImpl.serializeUI32(retBuffer, "", 0x29E1B589);
                    // Serialize exception name
                    serImpl.serializeString(retBuffer, "", "FirstException");
                    // Serialize exception data
                    ex_FirstException.serialize(serImpl, retBuffer, "");
			}
			catch(SecondException ex_SecondException) {
                    ex_SecondException.printStackTrace();
                    // Serialize return code (non-zero error code)
                    serImpl.serializeUI32(retBuffer, "", 0xD8044958);
                    // Serialize exception name
                    serImpl.serializeString(retBuffer, "", "SecondException");
                    // Serialize exception data
                    ex_SecondException.serialize(serImpl, retBuffer, "");
                }

                retMsg.setPayload(retBuffer.getByteBuffer());
                return retMsg;

            }
        } catch (IOException ex) {
            throw new RuntimeException(ex);
        }

        return null;

    }

}
