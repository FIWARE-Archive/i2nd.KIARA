 /* KIARA - Middleware for efficient and QoS/Security-aware invocation of services and exchange of messages
 *
 * Copyright (C) 2014 Proyectos y Sistemas de Mantenimiento S.L. (eProsima)
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library. If not, see <http://www.gnu.org/licenses/>.
 *
 *
 * @file CalculatorProxy.java
 * This file contains the proxy implementation.
 *
 * This file was generated by using the tool Kiaragen.
 *
 */


package com.kiara.calculator;

import com.google.common.util.concurrent.FutureCallback;
import com.google.common.util.concurrent.Futures;
import com.google.common.util.concurrent.ListenableFuture;

import com.kiara.netty.TransportMessageDispatcher;
import com.kiara.serialization.Serializer;
import com.kiara.serialization.impl.CDRSerializer;
import com.kiara.transport.Transport;
import com.kiara.transport.impl.TransportMessage;

import java.nio.ByteBuffer;

/**
 * Class containing the proxy implementation for all the services.
 *
 * @author Kiaragen tool.
 *
 */
class CalculatorProxy implements CalculatorClient {

	public CalculatorProxy(Serializer ser, Transport transport) {
		m_ser = (com.kiara.serialization.impl.SerializerImpl) ser;
		m_transport = (com.kiara.transport.impl.TransportImpl) transport;
		add_callback = null;
		subtract_callback = null;
	}


	private int add_required_size() {
		int op_size = 0;

		op_size += 4 + CDRSerializer.alignment(op_size, Integer.SIZE); // MessageID
		op_size += 4 + CDRSerializer.alignment(op_size, 4) + "Calculator".length() + 1; // Interface name
		op_size += 4 + CDRSerializer.alignment(op_size, 4) + "add".length() + 1; // Operation name
		op_size += 4 + CDRSerializer.alignment(op_size, 4);
		op_size += 4 + CDRSerializer.alignment(op_size, 4);

		return op_size;
	}

	private int subtract_required_size() {
		int op_size = 0;

		op_size += 4 + CDRSerializer.alignment(op_size, Integer.SIZE); // MessageID
		op_size += 4 + CDRSerializer.alignment(op_size, 4) + "Calculator".length() + 1; // Interface name
		op_size += 4 + CDRSerializer.alignment(op_size, 4) + "subtract".length() + 1; // Operation name
		op_size += 4 + CDRSerializer.alignment(op_size, 4);
		op_size += 4 + CDRSerializer.alignment(op_size, 4);

		return op_size;
	}

	public int add(/*in*/ int n1, /*in*/ int n2) {
		if (m_ser != null && m_transport != null) {
			ByteBuffer buffer = ByteBuffer.allocate(add_required_size());
			final TransportMessage trequest = m_transport.createTransportMessage(null);
	        trequest.setPayload(buffer);

	        final Object messageId = m_ser.getNewMessageId();
	        m_ser.serializeMessageId(trequest, messageId);
			m_ser.serializeService(trequest, "Calculator");
			m_ser.serializeOperation(trequest, "add");
			m_ser.serializeI32(trequest, "", n1);
			m_ser.serializeI32(trequest, "", n2);
			trequest.getPayload().flip();

			final TransportMessageDispatcher dispatcher = new TransportMessageDispatcher(messageId, m_ser, m_transport);
	        m_transport.send(trequest);

	        try {
			TransportMessage tresponse = dispatcher.get();
			if (tresponse != null && tresponse.getPayload() != null) {
	                final ByteBuffer buf = tresponse.getPayload().duplicate();
				buf.rewind();
				TransportMessage copy = m_transport.createTransportMessage(null);
				copy.setPayload(buf);
				final Object responseMessageId = m_ser.deserializeMessageId(copy);

					int ret = m_ser.deserializeI32(copy, "");
					return ret;
	            }
	        } catch (Exception ex) {
	            throw new RuntimeException(ex);
	        }

		}

		return 0;
	}

	public int subtract(/*in*/ int n1, /*in*/ int n2) {
		if (m_ser != null && m_transport != null) {
			ByteBuffer buffer = ByteBuffer.allocate(subtract_required_size());
			final TransportMessage trequest = m_transport.createTransportMessage(null);
	        trequest.setPayload(buffer);

	        final Object messageId = m_ser.getNewMessageId();
	        m_ser.serializeMessageId(trequest, messageId);
			m_ser.serializeService(trequest, "Calculator");
			m_ser.serializeOperation(trequest, "subtract");
			m_ser.serializeI32(trequest, "", n1);
			m_ser.serializeI32(trequest, "", n2);
			trequest.getPayload().flip();

			final TransportMessageDispatcher dispatcher = new TransportMessageDispatcher(messageId, m_ser, m_transport);
	        m_transport.send(trequest);

	        try {
			TransportMessage tresponse = dispatcher.get();
			if (tresponse != null && tresponse.getPayload() != null) {
	                final ByteBuffer buf = tresponse.getPayload().duplicate();
				buf.rewind();
				TransportMessage copy = m_transport.createTransportMessage(null);
				copy.setPayload(buf);
				final Object responseMessageId = m_ser.deserializeMessageId(copy);

					int ret = m_ser.deserializeI32(copy, "");
					return ret;
	            }
	        } catch (Exception ex) {
	            throw new RuntimeException(ex);
	        }

		}

		return 0;
	}


	public void add(/*in*/ int n1, /*in*/ int n2, add_AsyncCallback callback) {

		if (m_ser != null && m_transport != null) {
			ByteBuffer buffer = ByteBuffer.allocate(100);
			final TransportMessage trequest = m_transport.createTransportMessage(null);
	        trequest.setPayload(buffer);

	        final Object messageId = m_ser.getNewMessageId();
	        m_ser.serializeMessageId(trequest, messageId);
			m_ser.serializeService(trequest, "Calculator");
			m_ser.serializeOperation(trequest, "add");
			m_ser.serializeI32(trequest, "", n1);
			m_ser.serializeI32(trequest, "", n2);

			trequest.getPayload().flip();

			final TransportMessageDispatcher dispatcher = new TransportMessageDispatcher(messageId, m_ser, m_transport);

			add_callback = callback;

			Futures.addCallback((ListenableFuture) dispatcher, new FutureCallback<TransportMessage> () {

				public void onSuccess(TransportMessage result) {
					final ByteBuffer buf = result.getPayload().duplicate();
				buf.rewind();
				TransportMessage copy = m_transport.createTransportMessage(null);
				copy.setPayload(buf);

					add_callback.process(copy, m_ser);
				}

				public void onFailure(Throwable t) {
					add_callback.onFailure(t);
				}

			});

			m_transport.send(trequest);

		}

		return;
	}

	public void subtract(/*in*/ int n1, /*in*/ int n2, subtract_AsyncCallback callback) {

		if (m_ser != null && m_transport != null) {
			ByteBuffer buffer = ByteBuffer.allocate(100);
			final TransportMessage trequest = m_transport.createTransportMessage(null);
	        trequest.setPayload(buffer);

	        final Object messageId = m_ser.getNewMessageId();
	        m_ser.serializeMessageId(trequest, messageId);
			m_ser.serializeService(trequest, "Calculator");
			m_ser.serializeOperation(trequest, "subtract");
			m_ser.serializeI32(trequest, "", n1);
			m_ser.serializeI32(trequest, "", n2);

			trequest.getPayload().flip();

			final TransportMessageDispatcher dispatcher = new TransportMessageDispatcher(messageId, m_ser, m_transport);

			subtract_callback = callback;

			Futures.addCallback((ListenableFuture) dispatcher, new FutureCallback<TransportMessage> () {

				public void onSuccess(TransportMessage result) {
					final ByteBuffer buf = result.getPayload().duplicate();
				buf.rewind();
				TransportMessage copy = m_transport.createTransportMessage(null);
				copy.setPayload(buf);

					subtract_callback.process(copy, m_ser);
				}

				public void onFailure(Throwable t) {
					subtract_callback.onFailure(t);
				}

			});

			m_transport.send(trequest);

		}

		return;
	}


	private com.kiara.serialization.impl.SerializerImpl m_ser = null;
    private com.kiara.transport.impl.TransportImpl m_transport = null;

    private add_AsyncCallback add_callback;
    private subtract_AsyncCallback subtract_callback;

}
